<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Local Detective Board</title>
<style>
html, body { height: 100%; margin: 0; background: #0e0f12; color: #eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
#app { height: 100%; display: grid; grid-template-rows: auto 1fr; }
header { padding: 8px 12px; background: #16181d; border-bottom: 1px solid #23252b; font-size: 14px; display: flex; gap: 12px; align-items: center; }
header button { background: #2b2f36; border: 1px solid #3c3f47; color: #fff; border-radius: 4px; padding: 4px 8px; cursor: pointer; }
header button:hover { background: #3b3f48; }
header .hint { opacity: .8 }
header kbd { background: #23252b; padding: 2px 6px; border-radius: 4px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }


#board-wrap { position: relative; overflow: hidden; }
#board-bg { position: absolute; inset: 0; background-image: radial-gradient(#2b2f36 1px, transparent 1px), radial-gradient(#1c1f24 1px, transparent 1px); background-position: 0 0, 25px 25px; background-size: 50px 50px; }


#viewport { position: absolute; inset: 0; cursor: grab; }
#viewport.grabbing { cursor: grabbing; }


#world { position: absolute; top: 0; left: 0; transform-origin: 0 0; }


svg#wires { position: absolute; top: 0; left: 0; width: 100000px; height: 100000px; pointer-events: none; z-index: 100; }


.pin { position: absolute; width: 10px; height: 10px; border-radius: 50%; background: #f44336; border: 1px solid #7a1e18; box-shadow: 0 0 0 2px rgba(0,0,0,.35); transform: translate(-5px, -5px); z-index: 200; }
.pin::after { content: ""; position: absolute; left: 4px; top: -10px; width: 2px; height: 10px; background: #7a1e18; }


.note { position: absolute; min-width: 160px; max-width: 320px; background: #fff6a9; color: #222; border: 1px solid #e0d987; box-shadow: 0 10px 18px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.6); border-radius: 6px; padding: 8px; transform: translate(-50%, -50%); }
.note[contenteditable="true"] { outline: 2px dashed #c7bf77; }
.note .meta { font-size: 11px; color: #6b6b6b; margin-top: 6px; user-select: none; }


.image { position: absolute; transform: translate(-50%, -50%); max-width: 640px; max-height: 480px; box-shadow: 0 10px 18px rgba(0,0,0,.5); border: 2px solid #1c1f24; border-radius: 6px; background: #111; }


line.thread { stroke: #ffffff; stroke-width: 2; stroke-linecap: round; filter: drop-shadow(0 0 1px rgba(0,0,0,.7)); }
line.thread.live { stroke-dasharray: 5 4; }


#help { position: absolute; right: 10px; bottom: 10px; background: rgba(0,0,0,.6); border: 1px solid #2a2d33; padding: 8px 10px; border-radius: 8px; font-size: 12px; }
#help b { color: #fff; }

.arrow { position: absolute; width: 60px; height: 24px; transform: translate(-50%, -50%) rotate(0deg); z-index: 150; pointer-events: auto; }
.arrow svg { width: 100%; height: 100%; fill: none; stroke: #4da3ff; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round; filter: drop-shadow(0 0 2px rgba(0,0,0,.6)); }
</style>
</head>
<body>
<div id="app">
<header>
<button id="saveBtn">üíæ Save</button>
<button id="loadBtn">üìÇ Load</button>
<button id="restoreBackupBtn">‚è≤ Autobackup</button>
<button id="arrowBtn">‚û° Arrow</button>
<div class="hint">Local Detective Board</div>
<div class="hint">Double-click: <kbd>note</kbd></div>
<div class="hint">Right-click + hold + drag: <kbd>pin + thread + pin</kbd></div>
<div class="hint">Drag: <kbd>move</kbd></div>
<div class="hint">Wheel: <kbd>zoom</kbd></div>
<div class="hint">Paste image: <kbd>Ctrl+V</kbd></div>
<div class="hint">Shift + click: <kbd>Delete element</kbd></div>
</header>


<div id="board-wrap">
<div id="board-bg"></div>
<div id="viewport">
<div id="world">
<svg id="wires"></svg>
</div>
<div id="help">
<div><b>Tips</b></div>
<div>Right-click drag = connect pins.</div>
<div>Drag = move items (one or all). Double-click = add note. Paste = image.</div>
</div>
</div>
</div>
</div>
  <script>
    // Basic pan/zoom for an infinite-feel world
    const viewport = document.getElementById('viewport');
    const world = document.getElementById('world');
    const wires = document.getElementById('wires');

    // Make the world a huge canvas area
    const WORLD_W = 100000; // px
    const WORLD_H = 100000; // px
    world.style.width = WORLD_W + 'px';
    world.style.height = WORLD_H + 'px';

    let state = {
      scale: 1,
      minScale: 0.25,
      maxScale: 2.5,
      panX: WORLD_W / 2 - window.innerWidth / 2,
      panY: WORLD_H / 2 - window.innerHeight / 2,
      draggingBackground: false,
      dragStart: {x:0, y:0},
      panStart: {x:0, y:0},
      placingThread: null, // {startPinId, lineEl}
      draggingItem: null, // {el, dx, dy}
      idCounter: 1,
      pins: new Map(), // id -> {x,y}
      threads: [], // {aId, bId, lineEl}
    };

    function applyTransform() {
      world.style.transform = `translate(${-state.panX}px, ${-state.panY}px) scale(${state.scale})`;
      // wires is inside world, so no separate transform needed
    }

    applyTransform();

    function screenToWorld(clientX, clientY) {
      const rect = viewport.getBoundingClientRect();
      const sx = (clientX - rect.left);
      const sy = (clientY - rect.top);
      return {
        x: (sx + state.panX) / state.scale,
        y: (sy + state.panY) / state.scale
      };
    }

    function worldToScreen(x, y) {
      const rect = viewport.getBoundingClientRect();
      return {
        x: (x * state.scale) - state.panX + rect.left,
        y: (y * state.scale) - state.panY + rect.top
      };
    }

    viewport.addEventListener('mousedown', (e) => {
      const target  = e.target;
      const worldPos = screenToWorld(e.clientX, e.clientY);

      // --- LEFT BUTTON: pan background or drag object ---
      if (e.button === 0) {
        // 1) If empty space -> start panning
        if (target === viewport || target === world || target === document.getElementById('board-bg')) {
          state.draggingBackground = true;
          viewport.classList.add('grabbing');
          state.dragStart = { x: e.clientX, y: e.clientY };
          state.panStart  = { x: state.panX, y: state.panY };
          e.preventDefault();
          return;
        }

        // 2) Try to drag the nearest draggable ancestor (pin/note/image/arrow)
        const handle = target.closest('.pin, .note, .image, .arrow');
        if (handle) {
          const bb = handle.getBoundingClientRect();
          const offset = screenToWorld(bb.left + bb.width/2, bb.top + bb.height/2);
          state.draggingItem = { el: handle, dx: worldPos.x - offset.x, dy: worldPos.y - offset.y };
          e.preventDefault(); // avoid text selection while dragging notes
          return;
        }
      }

      // --- RIGHT BUTTON: start thread (allow creating pin anywhere) ---
      if (e.button === 2) {
        const { id: aId } = createPin(worldPos.x, worldPos.y);
        const live = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        live.classList.add('thread', 'live');
        wires.appendChild(live);
        updateLine(live, worldPos.x, worldPos.y, worldPos.x, worldPos.y);
        state.placingThread = { startPinId: aId, lineEl: live };
        e.preventDefault();
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (state.draggingBackground) {
        const dx = e.clientX - state.dragStart.x;
        const dy = e.clientY - state.dragStart.y;
        state.panX = state.panStart.x - dx;
        state.panY = state.panStart.y - dy;
        applyTransform();
      }
    });

    window.addEventListener('mouseup', () => {
      state.draggingBackground = false;
      viewport.classList.remove('grabbing');
    });

    // Zoom with wheel
    viewport.addEventListener('wheel', (e) => {
      if (!e.ctrlKey) {
        e.preventDefault();
        const { x, y } = screenToWorld(e.clientX, e.clientY);
        const prevScale = state.scale;
        const delta = Math.sign(e.deltaY);
        state.scale = Math.min(state.maxScale, Math.max(state.minScale, state.scale * (delta > 0 ? 0.9 : 1.1)));
        // Keep mouse position stable while zooming
        const { x: sx, y: sy } = worldToScreen(x, y);
        state.panX += (sx - e.clientX);
        state.panY += (sy - e.clientY);
        applyTransform();
      }
    }, { passive: false });

    // Prevent the default context menu so right-click is ours
    window.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });

    function newId(prefix) { return prefix + (state.idCounter++); }

    // Create pin at world coords
    function createPin(x, y) {
      const id = newId('pin_');
      const el = document.createElement('div');
      el.className = 'pin';
      el.dataset.id = id;
      positionEl(el, x, y, true);
      world.appendChild(el);
      state.pins.set(id, { x, y, el });
      return { id, el };
    }

    // Position element by world coords
    function positionEl(el, x, y, center=false) {
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      if (center && !el.classList.contains('pin')) {
        const match = el.style.transform.match(/rotate\([^)]*\)/);
        const rotation = match ? match[0] : '';
        el.style.transform = `translate(-50%, -50%) ${rotation}`;
      }
    }

    // Create a thread line connecting two pins
    function createThread(aId, bId) {
      const a = state.pins.get(aId);
      const b = state.pins.get(bId);
      if (!a || !b) return null;
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.classList.add('thread');
      wires.appendChild(line);
      updateLine(line, a.x, a.y, b.x, b.y);
      const t = { aId, bId, lineEl: line };
      state.threads.push(t);
      return t;
    }

    function updateLine(line, x1, y1, x2, y2) {
      line.setAttribute('x1', x1);
      line.setAttribute('y1', y1);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', y2);
    }

    function updateConnectedThreads(pinId) {
      const p = state.pins.get(pinId);
      if (!p) return;
      for (const t of state.threads) {
        if (t.aId === pinId || t.bId === pinId) {
          const a = state.pins.get(t.aId);
          const b = state.pins.get(t.bId);
          if (a && b) updateLine(t.lineEl, a.x, a.y, b.x, b.y);
        }
      }
    }

    window.addEventListener('mousemove', (e) => {
      const worldPos = screenToWorld(e.clientX, e.clientY);
      // Move item with right-drag
      if (state.draggingItem) {
        const { el, dx, dy } = state.draggingItem;
        const x = worldPos.x - dx;
        const y = worldPos.y - dy;
        positionEl(el, x, y, !el.classList.contains('pin'));
        // Update stored coords and threads if pin
        if (el.classList.contains('pin')) {
          const id = el.dataset.id;
          const pin = state.pins.get(id);
          if (pin) { pin.x = x; pin.y = y; updateConnectedThreads(id); }
        }
        return;
      }

      // Live thread preview
      if (state.placingThread) {
        const a = state.pins.get(state.placingThread.startPinId);
        if (a) updateLine(state.placingThread.lineEl, a.x, a.y, worldPos.x, worldPos.y);
      }
    });

    window.addEventListener('mouseup', (e) => {
      if (state.draggingBackground) {
        state.draggingBackground = false;
        viewport.classList.remove('grabbing');
      }
      if (state.draggingItem) {
        state.draggingItem = null;
      }

      // Finish thread only on right-button release
      if (state.placingThread && e.button === 2) {
        const worldPos = screenToWorld(e.clientX, e.clientY);
        const target = document.elementFromPoint(e.clientX, e.clientY);
        const bPinId = (target && target.classList && target.classList.contains('pin'))
          ? target.dataset.id
          : createPin(worldPos.x, worldPos.y).id;

        state.placingThread.lineEl.remove();
        createThread(state.placingThread.startPinId, bPinId);
        state.placingThread = null;
      }
    });

    // Double click to create a note
    viewport.addEventListener('dblclick', (e) => {
    // Click anywhere outside an active note to finalize it
    window.addEventListener('mousedown', (e) => {
      const active = document.querySelector('.note[contenteditable="true"]');
      if (!active) return;
      if (!e.target.closest('.note')) {
        active.removeAttribute('contenteditable');
      }
    });

      const target = e.target;
      // If double click on an existing note, re-enter edit mode
      if (target.classList.contains('note')) {
        target.setAttribute('contenteditable', 'true');
        target.focus();
        return;
      }
      const { x, y } = screenToWorld(e.clientX, e.clientY);
      createNote(x, y);
    });

    function createNote(x, y) {
      const id = newId('note_');
      const note = document.createElement('div');
      note.className = 'note';
      note.dataset.id = id;
      note.setAttribute('contenteditable', 'true');
      note.textContent = '';
      positionEl(note, x, y, true);
      world.appendChild(note);
      note.focus();

      // --- enter handling ---
      note.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter' && !ev.shiftKey) {
          ev.preventDefault();
          note.blur(); // triggers the blur handler below
        } 
      });

      // Commit (finalize) on blur
      note.addEventListener('blur', () => {
        note.removeAttribute('contenteditable');
      });

      return note;
    }

    // Paste image from clipboard at cursor
    window.addEventListener('paste', (e) => {
      const items = e.clipboardData && e.clipboardData.items;
      if (!items) return;
      for (const item of items) {
        if (item.type.indexOf('image') === 0) {
          const blob = item.getAsFile();
          const reader = new FileReader();
          reader.onload = function(evt) {
            const img = document.createElement('img');
            img.src = evt.target.result; // Base64 data URL
            img.className = 'image';
            img.dataset.id = newId('img_');
            const { x, y } = screenToWorld(lastMouse.x, lastMouse.y);
            positionEl(img, x, y, true);
            world.appendChild(img);
          };
          reader.readAsDataURL(blob);
          break;
        }
      }
    });

    // Track last mouse for paste placement
    let lastMouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
    window.addEventListener('mousemove', (e) => { lastMouse = { x: e.clientX, y: e.clientY }; });

    // Keep threads updated when window resizes (not strictly necessary since we use world coords)
    window.addEventListener('resize', applyTransform);

    const saveBtn = document.getElementById('saveBtn');
    const loadBtn = document.getElementById('loadBtn');


    saveBtn.addEventListener('click', () => {
    const data = {
        pins: Array.from(state.pins.entries()).map(([id, p]) => ({ id, x: p.x, y: p.y })),
        threads: state.threads.map(t => ({ aId: t.aId, bId: t.bId })),
        notes: Array.from(world.querySelectorAll('.note')).map(n => ({ id: n.dataset.id, x: parseFloat(n.style.left), y: parseFloat(n.style.top), text: n.textContent })),
        images: Array.from(world.querySelectorAll('img.image')).map(i => ({ id: i.dataset.id, x: parseFloat(i.style.left), y: parseFloat(i.style.top), src: i.src })),
        arrows: Array.from(world.querySelectorAll('.arrow')).map(a => ({
          id: a.dataset.id,
          x: parseFloat(a.style.left),
          y: parseFloat(a.style.top),
          rotation: parseFloat(a.style.transform.match(/rotate\(([-\d.]+)/)?.[1] || 0)
        }))
    };
    const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
    const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'detective_board.json';
        a.click();
        URL.revokeObjectURL(a.href);
    });

    world.addEventListener('click', (e) => {
      if (!e.shiftKey) return;          // only when Shift held
      const el = e.target;
      if (!(el instanceof HTMLElement)) return;

      // Delete pins and their threads
      if (el.classList.contains('pin')) {
        const pinId = el.dataset.id;
        // remove threads connected to this pin
        state.threads = state.threads.filter(t => {
          if (t.aId === pinId || t.bId === pinId) {
            t.lineEl.remove();
            return false;
          }
          return true;
        });
        state.pins.delete(pinId);
        el.remove();
        return;
      }

    // Delete notes or images
    if (el.classList.contains('note') || el.classList.contains('image') || el.classList.contains('arrow')) {
      el.remove();
      return;
    }
    });


    loadBtn.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const text = await file.text();
        const data = JSON.parse(text);
        loadFromData(data);
      };
      input.click();
    });

    const arrowBtn = document.getElementById('arrowBtn');
    arrowBtn.addEventListener('click', () => {
      // remove old chooser if open
      const old = document.getElementById('arrowChooser');
      if (old) old.remove();

      const chooser = document.createElement('div');
      chooser.id = 'arrowChooser';
      chooser.style.position = 'absolute';
      chooser.style.top = '40px';
      chooser.style.left = '10px';
      chooser.style.background = '#1a1c20';
      chooser.style.border = '1px solid #333';
      chooser.style.borderRadius = '6px';
      chooser.style.padding = '6px';
      chooser.style.display = 'grid';
      chooser.style.gridTemplateColumns = 'repeat(3, 40px)';
      chooser.style.gap = '4px';
      chooser.style.zIndex = '999';
      chooser.style.boxShadow = '0 4px 8px rgba(0,0,0,.6)';

      const dirs = [
        ['NW', 225], ['N', 270], ['NE', 315],
        ['W', 180], [null, null], ['E', 0],
        ['SW', 135], ['S', 90], ['SE', 45]
      ];

      for (const [name, angle] of dirs) {
        const cell = document.createElement('div');
        cell.style.width = '40px';
        cell.style.height = '40px';
        cell.style.display = 'flex';
        cell.style.alignItems = 'center';
        cell.style.justifyContent = 'center';
        if (!name) { chooser.appendChild(cell); continue; }
        cell.style.cursor = 'pointer';
        cell.title = name;

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '30');
        svg.setAttribute('height', '30');
        svg.style.pointerEvents = 'none';
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M5 12 H25 M25 12 L18 6 M25 12 L18 18');
        path.setAttribute('stroke', '#4da3ff');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.setAttribute('fill', 'none');
        svg.style.transform = `rotate(${angle}deg)`;
        svg.appendChild(path);
        cell.appendChild(svg);

        cell.addEventListener('click', () => {
          chooser.remove();
          createArrow(angle);
        });

        chooser.appendChild(cell);
      }

      document.body.appendChild(chooser);

      // click outside to close
      const close = (e) => {
        if (!chooser.contains(e.target)) {
          chooser.remove();
          document.removeEventListener('click', close);
        }
      };
      setTimeout(() => document.addEventListener('click', close), 10);
    });

    function createArrow(angle) {
      const id = newId('arrow_');
      const arrow = document.createElement('div');
      arrow.className = 'arrow';
      arrow.dataset.id = id;

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.style.pointerEvents = 'none';
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', 'M5 12 H50 M50 12 L40 4 M50 12 L40 20');
      svg.appendChild(path);
      arrow.appendChild(svg);

      const x = state.panX + window.innerWidth / 2;
      const y = state.panY + window.innerHeight / 2;
      positionEl(arrow, x, y, true);
      arrow.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
      world.appendChild(arrow);
    }

    function serializeBoard() {
      return JSON.stringify({
        pins: Array.from(state.pins.entries()).map(([id, p]) => ({ id, x: p.x, y: p.y })),
        threads: state.threads.map(t => ({ aId: t.aId, bId: t.bId })),
        notes: Array.from(world.querySelectorAll('.note')).map(n => ({
          id: n.dataset.id,
          x: parseFloat(n.style.left),
          y: parseFloat(n.style.top),
          text: n.textContent
        })),
        images: Array.from(world.querySelectorAll('img.image')).map(i => ({
          id: i.dataset.id,
          x: parseFloat(i.style.left),
          y: parseFloat(i.style.top),
          src: i.src
        })),
        arrows: Array.from(world.querySelectorAll('.arrow')).map(a => ({
          id: a.dataset.id,
          x: parseFloat(a.style.left),
          y: parseFloat(a.style.top),
          rotation: parseFloat(a.style.transform.match(/rotate\(([-\d.]+)/)?.[1] || 0)
        }))
      });
    }

    function loadFromData(data) {
      // Remove existing elements except the wires SVG
      world.querySelectorAll('.pin, .note, .image, .arrow').forEach(el => el.remove());
      wires.querySelectorAll('.thread').forEach(el => el.remove());

      state.pins.clear();
      state.threads = [];

      // Recreate pins directly under their original IDs
      for (const p of data.pins || []) {
        const el = document.createElement('div');
        el.className = 'pin';
        el.dataset.id = p.id;
        positionEl(el, p.x, p.y);
        world.appendChild(el);
        state.pins.set(p.id, { x: p.x, y: p.y, el });
      }

      // Recreate notes
      for (const n of data.notes || []) {
        const note = document.createElement('div');
        note.className = 'note';
        note.dataset.id = n.id;
        note.textContent = n.text;
        positionEl(note, n.x, n.y, true);
        world.appendChild(note);

        note.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter' && ev.ctrlKey) {
            ev.preventDefault();
            document.execCommand('insertHTML', false, '<br><br>');
            return;
          }
          if (ev.key === 'Enter' && !ev.ctrlKey) {
            ev.preventDefault();
            note.removeAttribute('contenteditable');
          }
        });
      }

      // Recreate images
      for (const i of data.images || []) {
        const img = document.createElement('img');
        img.className = 'image';
        img.dataset.id = i.id;
        img.src = i.src;
        positionEl(img, i.x, i.y, true);
        world.appendChild(img);
      }

      // Recreate arrows
      for (const a of data.arrows || []) {
        const arrow = document.createElement('div');
        arrow.className = 'arrow';
        arrow.dataset.id = a.id;
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.style.pointerEvents = 'none';
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M5 12 H50 M50 12 L40 4 M50 12 L40 20');
        svg.appendChild(path);
        arrow.appendChild(svg);
        positionEl(arrow, a.x, a.y, true);
        arrow.style.transform = `translate(-50%, -50%) rotate(${a.rotation}deg)`;
        world.appendChild(arrow);
      }

      // Recreate threads
      for (const t of data.threads || []) {
        createThread(t.aId, t.bId);
      }

      // Refresh connections
      for (const [id] of state.pins) updateConnectedThreads(id);

      // Resume id counter
      const allIds = [
        ...(data.pins || []).map(p => p.id),
        ...(data.notes || []).map(n => n.id),
        ...(data.images || []).map(i => i.id)
      ];
      const nums = allIds.map(id => parseInt(id.replace(/\D/g, ''))).filter(Number.isFinite);
      state.idCounter = Math.max(1, ...nums) + 1;
    }

    let lastBackupHash = null;

    function autoBackup() {
      try {
        const isEmptyBoard = (
          state.pins.size === 0 &&
          state.threads.length === 0 &&
          world.querySelectorAll('.note, .image, .arrow').length === 0
        );
        if (isEmptyBoard) return;

        const data = serializeBoard();
        const hash = awaitHash(data); // lightweight hash function

        if (hash === lastBackupHash) {
          console.log('No changes since last backup ‚Äî skipped.');
          return;
        }
        lastBackupHash = hash;

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const key = `detectiveBoardBackup_${timestamp}_${Math.random().toString(36).slice(2, 8)}`;
        localStorage.setItem(key, data);
        console.log('Auto-saved backup', key);
        cleanupBackups();
      } catch (err) {
        console.error('Auto-backup failed:', err);
      }
    }

    function awaitHash(str) {
      let h = 0;
      for (let i = 0; i < str.length; i++)
        h = Math.imul(31, h) + str.charCodeAt(i) | 0;
      return h >>> 0;
    }

    setInterval(autoBackup, 60000); // every minute

    restoreBackupBtn.addEventListener('click', () => {
      const keys = Object.keys(localStorage)
        .filter(k => k.startsWith('detectiveBoardBackup_'))
        .sort()
        .reverse(); // newest first

      if (!keys.length) {
        alert('No backups found.');
        return;
      }

      const chooser = document.createElement('div');
      chooser.style.position = 'absolute';
      chooser.style.top = '60px';
      chooser.style.left = '10px';
      chooser.style.background = '#1a1c20';
      chooser.style.border = '1px solid #333';
      chooser.style.borderRadius = '6px';
      chooser.style.padding = '6px 10px';
      chooser.style.display = 'flex';
      chooser.style.flexDirection = 'column';
      chooser.style.maxHeight = '300px';
      chooser.style.overflowY = 'auto';
      chooser.style.zIndex = '9999';
      chooser.style.boxShadow = '0 4px 8px rgba(0,0,0,.6)';

      const title = document.createElement('div');
      title.textContent = 'Select backup to restore:';
      title.style.marginBottom = '6px';
      title.style.color = '#ccc';
      chooser.appendChild(title);

      for (const key of keys) {
        const btn = document.createElement('button');
        btn.textContent = key.replace('detectiveBoardBackup_', '');
        btn.style.margin = '2px 0';
        btn.style.background = '#2b2f36';
        btn.style.color = '#fff';
        btn.style.border = '1px solid #3c3f47';
        btn.style.borderRadius = '4px';
        btn.style.padding = '4px 6px';
        btn.style.cursor = 'pointer';
        btn.addEventListener('click', () => {
          if (confirm(`Restore this backup?\n${key}`)) {
            try {
              const data = JSON.parse(localStorage.getItem(key));
              loadFromData(data);
              chooser.remove();
            } catch (err) {
              alert(`Failed to load backup:\n${err}`);
            }
          }
        });
        chooser.appendChild(btn);
      }

      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Cancel';
      closeBtn.style.marginTop = '8px';
      closeBtn.style.background = '#3a3d43';
      closeBtn.style.color = '#ccc';
      closeBtn.style.border = '1px solid #444';
      closeBtn.style.borderRadius = '4px';
      closeBtn.style.padding = '4px 6px';
      closeBtn.style.cursor = 'pointer';
      closeBtn.addEventListener('click', () => chooser.remove());
      chooser.appendChild(closeBtn);

      document.body.appendChild(chooser);

      // Close chooser when clicking outside
      const outsideClickHandler = (e) => {
        if (!chooser.contains(e.target)) {
          chooser.remove();
          document.removeEventListener('click', outsideClickHandler);
        }
      };
      setTimeout(() => document.addEventListener('click', outsideClickHandler), 10);
    });


    function cleanupBackups(maxCount = 10) {
      const keys = Object.keys(localStorage)
        .filter(k => k.startsWith('detectiveBoardBackup_'))
        .sort(); // oldest first, because ISO timestamps sort lexicographically

      while (keys.length > maxCount) {
        const key = keys.shift();
        localStorage.removeItem(key);
        console.log('Removed old backup', key);
      }
    }
  </script>
</body>
</html>
